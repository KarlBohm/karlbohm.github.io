---
layout: post
title:  "数理逻辑 1：一点记号和其他"
date:   2022-02-07 00:34:50 +0800
categories: 数理逻辑
description: 过了一朝又一朝，心中好似滚油浇。一路的盘费都花了，卖了宝剑我买了一把刀。
---
考虑到《数理逻辑十二讲》的可读性实在让人难以恭维（甚至连[课程网站](https://yiqinnju.github.io/course/MathLogic/MathLogic.html)上都直接承认了这一点），笔者目前在看李未的《数理逻辑》。两本书在组织结构上有些不同，反正我就按照后者的顺序来写了。本篇是“创刊号”，因此不会写太多内容，权当试（划）一下水罢了。

## 一阶逻辑的符号们

$ V $ 是可数无穷个变元 $x_1,x_2...x_n...$ 的集合

$C$ 是连接（联结？）词，有$\neg,\land,\lor,\to$, 李未的书中还有$\leftrightarrow$，反正可以用$\to$表示

$E$ 是等词 $\doteq$，需要注意的是$\doteq$与$=$并不一样，$a=b$ 与 $a\doteq b$ 并无关系

$Q$ 是量词 $\exists$ 和 $\forall$

$K$ 是两个括号() （警惕全半角符号混用！）

除此之外，我们还有几个非逻辑符：

$\mathscr{L}_c$ 是常元符号的集合 $\{c_0,c_1...\}$

$\mathscr L_f$ 是函数符号的集合$\{f_0,f_1...\}$

$\mathscr L_P$ 是谓词符号的集合$\{P_0,P_1...\}$，显然 $\doteq$ 是也是一个二元谓词。

考虑到任意知识的一阶语言都有相同的逻辑符号，因此我们可以通过描述后三个集合来描述一个一阶语言

## 项与公式

《十二讲》是先介绍命题逻辑再介绍一阶逻辑的，而李未的书直接从一阶逻辑开始引出的推理系统... 反正我就写这里了，命题逻辑以后再补。项是由以下的 BNF 定义的：

$$
t::=c|x|f(t_1,t_2...t_n)
$$

题外话：必须批判一下中文翻译的随意。一般来说范式指的 paradigm, 库恩用这个词来形容物理学研究中公认模式与共识的（虽然这个词在英文世界中也早已被滥用了）。然而在“巴库斯范式”这个词实际上是 Backus-Naur Form，作为一种表达方式与 paradigm 没有任何关系。我想翻译成巴库斯形式会更好一些... 

言归正传，通过项我们可以很轻松地递归定义逻辑公式：

$$
A::=t_1\doteq t_2|P(t_1...t_n)|\neg A|A\land B|A\lor B|A\to B|\forall xA|\exists xA
$$

由前两个方式定义的是原子公式，而后面定义的公式则是复合公式。不难发现这个形式包含了命题的定义：

$$
A::=\neg A|A\land B|A\lor B|A\to B
$$

毕竟一阶逻辑是命题逻辑在谓词和量词上的拓展。也正因为此，在一阶逻辑中需要考虑命题的项与其中的变元——这是命题逻辑所忽略的。

（需要注意的是复合公式实际上是带括号的，即 $(\lnot A),(A*B)$ 和 $(*xA)$，这样就不会出现优先级问题了）

## 自由变元

我们把某一个项 $t$ 的自由变元的集合记作 $FV(t)$，即若 $x\in FV(t)$，则 $x$ 为 $t$ 的一个自由变元。$FV(t)$ 是由以下三个规则递归定义的：

$$
\left \{ 
\begin{array}
FV(x)=\{x\},&x是一个变元\\
FV(c)=\varnothing,&c是一个常元\\
FV(f(t_1...t_n))=FV(t_1)\cup...\cup FV(t_n).
\end{array}
\right .
$$

这是相当易懂的。我们也称满足 $FV(t)=\varnothing$ 的项为基项。而对于公式的自由变元，我们则有一个更复杂的定义：

$$
\left\{
\begin{align}
&FV(t_1\doteq t_2)=FV(t_1)\cup FV(t_2)\\
&FV(P(t_1...t_n))=FV(t_1)\cup...\cup FV(t_n)\\
&FV(\neg A)=FV(A)\\
&FV(A*B)=FV(A)\cup FV(B),其中*是一个不为非的连接词\\
&FV(*xA)=FV(A)-\{x\}，其中*是一个量词
\end{align}\right .
$$

可以看出量词是对于变元范围的一个约束，被量词修饰的变元不是一个自由变元。需要注意的是在一个语句中同一个变元可能会出现多次，因此在语句中一个变元可以既作为自由变元也作为约束变元出现（但绝不会在同一次出现中满足两者）。对于一个不含自由变元（$FV(A)=\varnothing$）的公式 $A$，我们称其为一个语句。

## 替换

替换说的是我们可以使用一个项来替代一个自由变元来得到一个新的项或者公式。当然这种替换不能是盲目的，我们需要在替换的过程中保持同一性（虽然我们还没有定义所谓的“同一性”）。我们把 $s[t/x]$ 记为用 $t$ 替换 $s$ 中的自由变元 $x$ 的结果。对于项的替换，有一个简单的归纳定义：

$$
\begin{array}
y y[t/x]=y, &y\neq x且为变元\\
x[t/x]=t\\
c[t/x]=c, &c为常元\\
f(t_1...t_n)[t/x]=f(t_1[t/x]...t_n[t/x])
\end{array}
$$

很符合直觉的定义。不过在公式中，事情就变得复杂起来：公式中是存在约束的。对于除了量词之外的符号，替换的定义和自由变元的定义是相似的，这里不再重复。但对于量词，我们有如下的定义：

$$
\begin{aligned}
(*xA)[t/x]&=*xA\\
(*yA)[t/x]&=*yA[t/x]\qquad\qquad y\not\in FV(t)\\
(*yA)[t/x]&=*zA[z/y][t/x]\qquad其中y\in FV(t),z\notin FV(t)且z不是A中的变元
\end{aligned}
$$

这个东西就不是很直观了... 第一条规则说明了有约束的变元是不可以被替换的，这点应该比较容易理解。考虑这样一个例子：命题 $A$: $\exists x(x+y=0)$, 我们用 $y$ 替换 $x$，得到 $\exists y(y+y=0)$，这与第一个命题显然不是一回事（尽管我们没有规定什么是“正确的”替换，但这个结果应该不是我们想要的）。

第二条规则说明了只要替换的变量与约束变量无关就可以随意替换。$\exists x(x+y=0)$ 和 $\exists x(x+z=0)$ 并没有什么区别，只是名字的不同。不过如果替换的变量与约束变量有关，就需要使用第三条规则了。仍以上面那个命题为例，我们用 $x$ 替换 $y$， 由于 $x\in FV(x)$, 因此我们引入一个与命题无关的变量 $z$，得到 $\exists z(x+y=0)[z/x][x/y]=\exists z(z+y=0)[x/y]=\exists z(z+x=0)$。可以看出第三条规则是把约束变量用一个绝对无关（没有在公式中出现）的变量来替代，再进行之前的替换，否则替代过程结果由于受到量词的约束会变得十分混乱。（《十二讲》中对 $z$ 的序号也有所规定，我想这不是重点）

## Gödel 数

（笔者不太想装德语输入法，还是叫哥德尔好了）

哥德尔定理的证明的一个重要元素就是对所有的公式进行编号，而这个序号就是哥德尔数。李未将其形容为指针是十分恰当的。为了定义哥德尔数，我们首先要定义序列数：

$$
\langle a_1,a_2...a_n\rangle=p_1^{a_1+1}p_2^{a_2+1}...p_n^{a_n+1}，其中p_i为第i个素数
$$

显然序列与序列数是一一对应的。在序列数的基础上，我们可以定义哥德尔码——一种用数字对一阶语言中的所有符号加以编码的方式。由于笔者用的两本书上的定义方式有很大区别，因此在此略过具体细节。只要使用哥德尔码的归纳定义，我们就可以“轻松地”求出任何一个公式的哥德尔数——尽管这没有什么意义。我们需要的只是一个满足下面结论的编码方式：

$$
哥德尔编码是任意一个一阶语言到哥德尔数的一一映射
$$

这个结论应该是算数基本定理的推论。但具体证明也因编码而定，这里按下不表。我们会在本篇的结尾再次遇到哥德尔数的。

## 结构归纳证明

上文中很多概念都是用归纳的方式来定义的。其具有以下的形式：

$$
\begin{gather}
A是\text{xxx}\\
如果A_1...A_n是\text{xxx}，那么X是\text{xxx}
\end{gather}
$$

第一条是直接的定义，第二条则是一条生成规则。我们可以用一种更简便的形式来表示第二个式子：

$$
\frac{A_1...A_n}{X}
$$

我们规定这种分式的含义就是：如果 $A_1...A_n$ 这些前提成立，则结论 $X$ 也成立（或许这会让人想起刘易斯笔下的阿基里斯和乌龟的[对话](https://en.wikisource.org/wiki/What_the_Tortoise_Said_to_Achilles)，不过我想读者应该都是接受三段论的好人而不是 "A Kill-Ease"）。我们可以发现用归纳方法定义的内容存在两种类型的，一种是直接定义的（比如原子公式），另外一种则是由上述规则分式生成的（比如复合公式）。考虑到定义本身便蕴含了归纳规则，我们不难对用这种方式定义的对象使用归纳法——也就是结构归纳法：

$$
\begin{aligned}
&假定集合\mathbf Z的元素被一组规则定义,要证明集合\mathbf Z具有性质\Psi,我们只需要证明:\\
&I_1:\mathbf Z 中的每一个原子对象都具有\Psi\\
&I_2:对于每一条规则\frac{A_1...A_n}X,如果A_1...A_n都具有性质\Psi,则X也具有性质\Psi
\end{aligned}
$$

第一数学归纳法也可以被认为是一种结构归纳法，其中的规则是“若 $n$ 是自然数，则 $n+1$ 也是自然数”（皮亚诺公理的第二条） 。把结构归纳法运用到项和公式上，我们就可以得到项与公式的归纳证明法。这个工作很简单，笔者不再赘述。当然，考虑到数学归纳法的正确性是由皮亚诺公理的第五条所保证的，因此或许把结构归纳法转化为数学归纳法更能体现其正确性。于是我们就有了秩（用 $$rk(x)$$ 表示）的定义：

$$
\begin{gather}
对于项来说:\\rk(c)=1\\rk(x)=1\\rk(f(t_1...t_n))=\max\{rk(t_1)...rk(t_n) \}+1
\end{gather}
$$

$$
\begin{gather}对于公式来说:\\\text{rk}(t_1\doteq t_2)=1\\\text{rk}(P(t_1...t_n))=1\\\text{rk}(\lnot A)=\text{rk}(A)+1\\\text{rk}(A*B)=\max\{\text{rk}(A),\text{rk}(B)\}+1(*是一个不为非的连接词)\\\text{rk}(*xA)=\text{rk}(A)+1(*是一个量词)\end{gather}
$$

不难看出在秩的定义下使用数学归纳法和结构归纳法并没有本质上的区别，不过这下至少结构归纳法算是“名正而言顺”了，而不是依赖于“推理”之类的概念。通过结构归纳我们可以证明括号引理（公式中的左右括号个数相同）。下面给出一个简单证明：

我们首先对项进行归纳：

$T_1$: 每一个变元不带括号

$T_2$:每一个常元不带括号$T_3$: 对于函数 $f(t_1...t_n)$，根据归纳假设，任意一项 $t_n$ 满足左右括号数量相同, 且函数同时增加一对左右括号，因此假设仍然成立。因此结论对项成立。

接着对公式进行归纳：

$F_1$: 对于 $t_1\doteq t_2$，由于任意一项满足假设且等词不含括号，因此假设对此公式成立

$F_2$: 对于 $P(t_1...t_n)$，由于对于任意一项假设成立且谓词中同时含有一对左右括号，因此假设对此公式成立

$F_3$: 根据假设，公式 $A$ 中左右括号个数相同。同时 $(\lnot A)$ 同时增加了一对左右括号，因此假设对此公式成立。

$F_4$: 根据假设，任意公式 $A,B$ 中左右括号个数分别相等，不妨设 $A$ 有 $m$ 个左括号和 $m$ 个右括号，$B$ 有 $n$ 个左括号和 $n$ 个右括号，则 $(A\land B)$ 一共有 $m+n+1$ 个左括号和右括号，因此结论对 $(A\land B)$ 成立，同理也对其他形如 $(A*B)$ 的结论成立。

$F_5$: 根据假设，公式 $A$ 中左右括号个数相同。根据定义 $(\exists xA)$ 同时增加了一对左右括号，因此假设对于  $(\exists xA)$ 成立，同理也对 $(\forall xA)$ 成立。

综上所述，对于任意一个一阶语言中的公式，其中的左括号个数与右括号的个数相同。

## 结语

本篇尽管原则上是“笔记”，不过大多数还是对李未书上内容的简单复述... 希望之后会更好吧，也希望读者（如果有的话）能提供一些意见和建议。

## 题外话

