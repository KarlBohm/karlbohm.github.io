---
layout: post
title: "数理逻辑 0：命题逻辑和语义"
categories: 数理逻辑
date: 2022-03-07 00:22:22 +0800
description: 老马，这碗面条批下来啦！
---

考虑到开课了，还是得和课程安排对上，就先把之前略过去的命题逻辑写一写。不过考虑到其中的内容和一阶逻辑十分相似，可能就把一阶逻辑当命题逻辑来写了，所以看起来或许和命题逻辑大相径庭了。这种穿插着两种规范的写法貌似让可读性变得非常差... 

## 命题逻辑的语法

考虑到我们是先看了一圈一阶逻辑再回来的，这里实际上要做点减法：

$PS$ 是诸命题的集合, 其中包含了命题符 $P_1,P_2...P_n...$ 这个集合也是可数无穷的。

连接词只剩下四个了: $\lnot,\land,\lor,\rightarrow$

以及俩括号：()

少了这么多代号，我们也有一个比起公式更加简单的对命题的定义：

$$
P::=(\lnot A)|(A\land B)|(A\lor B)|(A\to B)
$$

（之前提过这个了，不过我加上了括号）对于命题我们也可以使用结构归纳，这里不再赘述了。

## 解释

一阶逻辑（以及命题逻辑）的目的是要形式化地描述领域知识（我竟然没在上一篇写这点），但要把这些抽象内容和具体知识连接起来，我们还需要解释和语义。在此之前，我们需要明确一个原理：

$$
排中原理:每个命题要么是真,要么没是假,别无他选。
$$

需要注意的是在一阶逻辑和解释之中名词使用上的不同，不过我想读者应该可以发现公式实际上也是这里说的命题（太混乱啦！）。

当然，排中律的正确性不由什么东西保证。实际上，是有理论否定排中律的，这就是著名的直觉主义。感兴趣的话不妨借一本《应用逻辑》吧（反正笔者一点没看懂）。

> 近日看到的一则笑话恰好也和直觉主义相关：
>
> -What kind of jokes does a classical logician tell an intuitionist?
>
> -Not-not jokes.

题外话太多了。解释是要建立在论域之上的。简单来说，论域是一个数学系统，其中包含了三个集合：基本元素，函数和命题的集合（这个词对应的是 Domain of discourse, 这样看意思就很明了了）。我们熟悉的自然数系统，实数系统之类的都是论域。有了这个概念我们就可以定义解释与结构了：

$$
\begin{aligned}
&解释是一个从一阶语言\mathscr L到论域\mathbf M的映射，其满足:\\
&1. 对于\mathscr L中的每一个常元c,I(c)是\mathbf M的元素\\
&2.对于\mathscr L中的每一个n元函数符号f,I(f)是\mathbf M上的n元函数\\
&3. 对于\mathscr L中的每一个 n元谓词符号
,I(P)是\mathbf M上的一个n元关系
\end{aligned}
$$

$$
考虑一个一阶语言的论域与解释的二元组(M,I)，我们称其为\mathscr L的一个结构
$$

作为一个例子，我们不妨构思一个简单的一阶语言（这里本来想移植一下《集异璧之大成》上面的小例子，不过写起来没有想象中简单，继续抄书了）：

考虑这样一个论域 $\mathbb N$，以及与其对应的一个一阶语言 $\mathscr A$，其中只有一个常元 $c$ ，三个函数 $f_1(x), f_2(x,y), f_3(x,y)$ 以及一个谓词 $P(x,y)$，我们就可以构造这样一个解释 $I$：

$$
\begin{aligned}
&I(c)=0\\
&I(f_1)=s\qquad(即自然数的后继)\\
&I(f_2)=+\\
&I(f_3)=\cdot\\
&I(P)=<
\end{aligned}
$$

需要注意的是这其中的符号问题：原则上一阶语言中的符号是可以和论域中的符号相似甚至相同的，但他们的作用域是不一样的（这一点我们已经在之前 $=$ 和 $\doteq$ 的区别中见过了）。不妨假设有另一个一阶语言 $\mathscr B$，其中有一个二元函数 $+$。我们可以为其构造一个解释 $I'$ 使得 $I'(+)=-$。因此为了避免歧义，我们需要区别元语言，解释和一阶语言中的用词。这也是为什么上文中使用了命题（虽然这个词在命题逻辑里面重载了）而不是公式。这一点在之后也要加以注意。

在求语义之前，我们还需要对变元赋值。一个赋值 $\sigma$ 是一个定义域为变元集合 $V$，值域为 $M$ 的映射，其把每一个 $\mathscr L$ 中的每一个变元 $x$ 都映射到论域的一个元素 $a$ 上，即 $\sigma(x)=a$. 这样我们就可以定义一阶语言的一个模型：

## 语义

语义实际上不一定是布尔值（这和赋值的值域有关），给定一个一阶语言 $\mathscr L$，论域 $\mathbf M[\sigma][\sigma]$ 和赋值 $\sigma$，我们有一个更一般的对项 $t$ 的语义 $t_{\mathbf M[\sigma][\sigma]}$ 的结构归纳定义：

$$
\begin{array}
？x_{\mathbf M[\sigma]}=\sigma(x)&x为变元\\
c_{\mathbf M[\sigma]}=c_{\mathbf M[\sigma]} &c为常元\\
(f(t_1...t_n)_{\mathbf M[\sigma]}=f_{\mathbf M[\sigma]}((t_1)_{\mathbf M[\sigma]}...(t_n)_{\mathbf M[\sigma]})

\end{array}
$$

（命题逻辑中的符号是 $\hat v()$，不过考虑到一阶逻辑更为重要所以采用了上述记号）。如果把赋值的值域对应到 $\{T,F\}$，我们就得到了通常使用的语义。但这个定义并不完全，在定义连接词的解释之前，我们对公式的语义仍然是束手无策的。于是我们定义 $\lnot$ 的语义是一元函数 $B_\lnot$，$\land,\lor,\rightarrow$ 的语义分别是 $B_\land,B_\lor,B_\rightarrow$ 他们的具体定义如下表（尽管读者肯定已经知晓了）

| P    | Q    | $B_\lnot(P)$ | $B_\land(P,Q)$ | $B_\lor(P,Q)$ | $B_{\rightarrow}(P,Q)$ |
| ---- | ---- | ------------ | -------------- | ------------- | ---------------------- |
| T    | T    | F            | T              | T             | T                      |
| T    | F    | F            | F              | T             | F                      |
| F    | T    | T            | F              | T             | T                      |
| F    | F    | T            | F              | F             | T                      |

 这绝不是最后一张真值表。值得注意的是在命题逻辑里面使用的是 $H_*$， 而在一阶逻辑里面使用的是 $B_*$，这里我们采用后者。

有了这些工具（实际上还没有 $\exists$ 和 $\forall$，不过这两个的求值的描述本身也不是完全符号化的），我们就可以用结构归纳来定义公式的语义（其中已经包含了命题逻辑中命题的定义）。这种剧情我们已经见过很多次了：

$$
\begin{aligned}
&(t_1\doteq t_2)_{\mathbf M[\sigma]}=\left\{\begin{array}aT,& (t_1)_{\mathbf M[\sigma]}=(t_2)_{\mathbf M[\sigma]}\\F,&\text{otherwise}  \end{array}\right .\\
&(P(t_1...t_n))_{\mathbf M[\sigma]}=P_{\mathbf M[\sigma]}((t_1)_{\mathbf M[\sigma]}...(t_n)_{\mathbf M[\sigma]})\\
&(\lnot A)_{\mathbf M[\sigma]}=B_{\lnot}(A_{\mathbf M[\sigma]})\\
&(A* B)_{\mathbf M[\sigma]}=B_*(A_{\mathbf M[\sigma]},B_{\mathbf M[\sigma]})\\
&(\forall x,A)_{\mathbf M[\sigma]}=\left \{\begin{array}2T,&对于任意的a\in M,A_{\mathbf M[\sigma[x_i:=a]]}=T\\F,& \text{otherwise}\end{array}\right .\\
&(\exists x,A)_{\mathbf M[\sigma]}=\left \{\begin{array}2T,&存在a\in M,A_{\mathbf M[\sigma[x_i:=a]]}=T\\F,& \text{otherwise}\end{array}\right .
\end{aligned}
$$

在此之上，我们有一些名词的定义：

满足：如果 $A_{\mathbf M[\sigma]}=T$，我们就称 $(M,\sigma)$ 满足 $A$，记作 $M\vDash _\sigma A$。相应的，如果存在这样的结构我们就称 $A$ 可满足。 如果任意的结构都可以满足 $A$，那么我们称 $A$ 是一个永真式（我更喜欢重言式这个称呼，听起来很厉害），记作 $\vDash A$。当然除此以外还有很多记号，其含义不难猜测就不一一列举了。

以上内容是一阶逻辑和命题逻辑共有的，接下来我们会专注于命题逻辑，研究一下析和范式和和析范式。（我仍然觉得不应该叫范式... 随它去了）

想要符合直觉的话，我们只需要把“析和”和“和析”从左到右写出来就好了：

$$
\begin{aligned}
规定下文P_{i,k}是命题符或命题符的否定，我们有如下定义:\\
一个符合析和范式的命题 A 指的是A=\bigvee^m_{i=1}\left(\bigwedge^n_{k=1}P_{i,k}\right)\\
而符合和析范式的命题B则是说B=\bigwedge^l_{j=1}\left(\bigvee^n_{k=1}Q_{j,k} \right)
\end{aligned}
$$

其中 $\bigvee$ 和 $\bigwedge$ 的定义是比较显然的。我们定义这两个“范式”的目的是为了将任何的布尔映射化为命题的形式。其实这件事情非常简单：只需要把真值表“展开”即可——这招在数字逻辑上也用得到。

证明这个结论也并不是难事，困难在于处理并不熟悉的符号。考虑到篇幅这里暂时略过，我们来看看自然推理系统。

## 自然推理系统

又称 G 推理系统。这个东西简直就是”新人杀手“——直接看严格定义对于智识并没有任何益处。但实际上从例子来理解 G 推理系统会很方便，其与日常生活中的逻辑还是十分相似的。但（遗憾的是）我们还是要先来定义几个符号：

$$
设\Gamma，\Delta为命题的有穷集合，我们称\Gamma\vdash\Delta 是一个序贯，其中\Gamma,\Delta 分别为序贯的前件和后件。
$$

这是啥？答曰：

$$
如果\Gamma\vdash A 可证，则\Gamma\vDash A 成立。
$$

什么是可证？先别忙。现在我们有了四个记号：推出关系：$\rightarrow$；可满足：$\vDash$ ；序贯 $\vdash$ 以及某种分式的约定（可以回顾一下[数理逻辑1](/数理逻辑/2022/02/10/数理逻辑0.html/)中对结构归纳的介绍）。这几个记号仿佛都在说同一件事情：我们能从左（上）边推出右（下）边。事实也的确如此，只是 $\rightarrow$ 是一阶逻辑中的符号，$\vDash$ 是语义中的符号而 $\vdash$ 和分式是 G 推理系统上的符号，$\vdash$ 说的是命题之间的推出而分式则是证明过程中的推出。在 G 推理系统的规则中， $\rightarrow $ 和 $\vdash$ 是可以相互转化的。通过推理规则建立证明树之后，便可以通过考察赋值把 $\vdash$ 变成 $\vDash$ 或 $\not\vDash$。

言归正传，定义了序贯之后我们就可以来看一看到底什么是 G 推理系统：（为了简洁起见，大多数规则中不会像《十二讲》那样加上 $\Gamma,\Theta$ 之类的命题集合，读者可以默认除了写出的部分前项和后项都是相同的，而是仿照 *Mathematical Logic for Computer Science* 上的写法，*Logic in Computer Science* 上的推理规则并不是序贯形式的，十分奇怪...）

> 如果想了解 *Mathematical Logic for Computer Science* 的结构可以看一下 jjppp 的[博客][https://www.cnblogs.com/jjppp/p/15840566.html]，和中文教材的内容出入不少。比如下述的推理规则实际上是由更一般的形式推出的，其正确性依赖于 soundness 和 completeness，这里不多谈。

$$
命题逻辑的自然推理系统由以下公理和规则组成:\\
公理:\Gamma,A,\Delta\vdash \Lambda,A,\Theta\\
规则:\quad\lnot L:\frac{\vdash A}{\lnot A\vdash},\lnot R:\frac{A\vdash}{\vdash\lnot A}\\
\lor L:\frac{A\vdash\quad B\vdash}{A\lor B\vdash},\lor R:\frac{\vdash A,B}{\vdash A\lor B}\\
\land L:\frac{A,B\vdash}{A\land B\vdash},\land R:\frac{\vdash A\quad \vdash B}{\vdash A\land B}\\
\rightarrow L:\frac{\vdash A\quad B\vdash}{A\rightarrow B\vdash},\rightarrow R:\frac{A\vdash B}{\vdash A\rightarrow B}\\\text{Cut}:\frac{\Gamma\vdash \Lambda,A\quad\Delta,A\vdash\Theta}{\Gamma,\Theta\vdash\Lambda,\Theta}
$$

这些规则可以——至少大部分可以——与我们的直觉所对应（我至少不太会解释和 $\lnot$ 相关的规则）。当然在没有赋值的情况下，我们也可以仅仅把他们看作是一种符号游戏。无论用什么眼光来看待，这些规则的最终目的是要对任意一组命题符号给出一个证明的过程，也就是证明树。然而证明树并不是以公理为根节点的一棵树，而是从特定命题中分散开的。这依赖于一个观察：上述规则的形式只有两种： $\frac{M}{N}$ 和 $\frac{M\quad M'}{N}$，具体内容相信就不用再多说了，唯一需要注意的是如果无法通过规则约化到公理的话是无法被称为证明树的。这样我们就可以定义可证了：

$$
\Gamma\vdash \Lambda 可证指存在\Gamma\vdash \Lambda的证明树
$$

这里给出一个小例子：

$$
\cfrac{\cfrac{\cfrac{\cfrac{{A\vdash A,B\quad B\vdash A,B}}{\vdash A,B,\lnot A\quad \vdash A,B,\lnot B}}{\vdash(A\lor B),(\lnot A\land \lnot B)}}{\lnot (A\lor B)\vdash(\lnot A\land \lnot B)}}{\vdash\lnot (A\lor B)\rightarrow(\lnot A \land \lnot B)}\\
因此 \vDash\lnot (A\lor B)\rightarrow(\lnot A \land \lnot B)，即其是永真的
$$

说明其是永真的用到了以下的定义：

$$
\begin{aligned}
&设\Gamma=\{A_1,A_2...A_m\},\Delta=\{B_1,B_2...B_n\}\\
&如果存在赋值\sigma 使得\sigma\vDash(A_1\and A_2...\land A_m)\land(\lnot B_1\land \lnot B_2...\land \lnot B_n)，则称\Gamma\vdash \Delta 有反例\\
&如果对于任意的赋值\sigma,都有 \sigma\vDash(A_1\and A_2...\land A_m)\rightarrow(B_1\lor B_2...\lor B_n)，则称\Gamma\vdash \Delta为有效的\\
&m=0时，如果\vdash\Delta 有反例则(\lnot B_1\land \lnot B_2...\lnot B_n)可满足，\vdash\Delta有效则(B_1\lor B_2...\lor B_n)永真\\
&n=0时，如果\Gamma\vdash 有反例则(A_1\and A_2...\land A_m)可满足，\Gamma\vdash有效则(A_1\and A_2...\land A_m)不可满足
\end{aligned}
$$

在这里我们再次看到了 $\rightarrow$ 和 $\vdash$ 的相似性：在讨论命题赋值的时候后者会很自然地退化为前者。

> 一点迷思：如果我们把分式的关系写作 $\rightarrow$ 的话，是否可以把 G 推理系统的推理过程用命题逻辑来表成命题呢？如果对这个命题进行推理是否是有意义的行为呢？笔者并不打算继续讨论，并打算干点别的东西，因为其已经浪费了一个下午尝试搞清楚各种概念了。

## 题外话：关于希尔伯特计划的胡言乱语

> 警惕笔者的胡言乱语，其中必定包含了事实性错误与误读！最好的做法是不要把它当回事，这样笔者也能心安一些。

决定论一直是一种充满了争议的看法——有人认为这是先定的和谐（尽管莱布尼茨本意不是这个意思），也有人认为这种观点纯粹是人类丑陋的自大。但是在数学之中，决定论比起一个想法更像是一个确凿的事实：如果公理已经确定的话，任何命题的对错应该也是确定的。因此，我们需要做的就是寻找走向这个命题的推导。

希尔伯特（大概）也是这么想的，不过他有着更加宏大的理想：我们需要形式化的数学语言以避免自然语言的模糊性；我们需要建立一个可以证明一切为真的陈述并且没有矛盾的数学体系并证明它；我们也需要找到一种可以自动判断任意命题正确性的方法（算法）。这也就是希尔伯特计划。换言之，希尔伯特希望通过这个方式来一劳永逸地解决所有数学问题。

这件事情看起来很难达成，不过我们可以通过推理系统来得到一个很直观但不准确的认识。在一个给定的一阶语言之下，我们可以通过推理来化约任意一个命题而不考虑其语义，其正确性可以完全由赋值得到。这样我们完全可以把数学看作是一套机械的符号操作——其中的语义只是由赋值得到的。这也正是形式主义这个说法的由来。（事实上，一阶逻辑正是在希尔伯特发起的数学公理化的浪潮中发展起来的，不过 G 推理系统实际上是在哥德尔不完备性定理之后由 Gentzen 提出的）形式主义的这种看法受到很多人的抨击，因为其对于数学“意义”的消解是无法被接受的。以彭罗斯为例，他坚信数学中非算法的部分——洞察与灵感——才是其真正重要的，也是形式主义无法通过符号游戏解决的。当然，我们先把论战放到一边，希尔伯特计划尽管充满了雄心壮志，但也是循序渐进的。实际上，在解决了一些基础问题之后，希尔伯特把重心放在了证明皮亚诺公理的一致性和完备性上（也就是说， 对于一个语言 $\mathscr L$ 中的表达式 $E$，我们都有 $T\vdash E$ 或 $T\vdash \lnot E$，且两者只能居其一）。在希尔伯特著名的23个问题之中，他把这个问题放在了第二位（第一位是连续统假说，结果前两问的结论都和哥德尔有关）。后面的事情上一篇已经提到过了，哥德尔的不完备性定理把希尔伯特计划一锅端了，而停机问题无解也让自动证明化为了泡影。希尔伯特那种古典主义一般优美而坚实的数学观被连根拔起，取而代之的是一些更加难以理解，却更加符合“现代化”的东西。实际上，如果我们回顾上一篇对哥德尔定理构造出的命题的解释：
$$
这个命题无法被证明
$$
不难发现这个命题的是真的，只是其无法在这个公理系统中被证明。彭罗斯认为这就是“数学洞察”的能力，是人类异于算法的地方。不过人类要解答的并非只有数学问题。

> 6.41 世界的意义必定在世界之外。
>
> <p align="right">——路德维希·维特根斯坦 《逻辑哲学论》</p>
> 

维特根斯坦是错误的，至少不存在什么原子事实，也无法对自然语言进行那般理想化的分析。不过这本1921年首次发表的小册子却与1931年的哥德尔不完备性定理遥相呼应，尝试用“不存在”来回答某些难题。维特根斯坦绝对没想到的是，在21世纪，有一位神棍脚本家用他的主题奏出了一些奇怪的变奏：

>世界的极限，就是我的界限吧... 
>
>如果世界就是我的话...... 为什么我会看不到你看到的世界呢？
>
>既然所有人都平等地拥有他们自己的世界的话，那么为什么世界会变成一个呢？

那个脚本家绝对不是抱着严肃的心态写下这种文字的，其中内容也丝毫经不起推敲。不过，对于一个失去了意义的世界，它能够从别的世界获取意义呢？

关于希尔伯特计划，有一份详细的[综述](https://arxiv.org/pdf/math/0508572.pdf)可以参考（虽然笔者并没有耐心读完它）。不过中文资料也有很多，比如[这篇](https://www.douban.com/note/722757653/?_i=65794510a5gl9Y)以及该作者的其他文章。关于彭罗斯对形式主义和数学的看法可以看看《皇帝新脑》（上一篇也提到了），即使作为科普读物来阅读也是相当好的。从维特根斯坦开始的部分都是牵强附会，并显然和上文的介绍没有任何关联，还望读者谅解。Kindle 上的那本《逻辑哲学论》陪笔者走过了半个初中和整个高中，因此如果选择离开或许也要从这里出发。其余也无需多言，感谢您能看到这里，在这里祝您早安、午安、晚安。
